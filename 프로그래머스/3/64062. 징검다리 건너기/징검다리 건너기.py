'''
최대 k칸을 건널 수 있음
그리디?
k는 1 이상 stones 길이 이하의 자연수
stones는 최대 200,000임.
내 생각대로 하면 안됨.

그냥 최대 k로 가게하면 되지 않을까? 그게 안되면 k-1 ... 1까지 -> 이게 안되면 종료
이게 항상 최선의 경우가 맞을까?
근데 문제가 있다 -> 징검다리 크기는 최대 200,000임.
그리고 각 배열은 최대 2억임
사람 수는 무제한임...
즉, 하나하나 모두 보는걸로 하면 시간초과가 뜬다는 것
[2 4 5 3 2 1 4 2 5 1]	
[2 4 4 3 2 0 4 2 4 1]
[2 4 3 3 1 0 4 1 4 1]
[2 4 3 3 0 0 4 0 4 1]
[2 4 2 2 0 0 3 0 4 0]
-> 가장 가까운거를 밟는다
ㅋㅋㅋㅋㅋㅋ 글쿠만...

k개의...
정리
k-1개가 모두 0이 되면 종료
슬라이딩 윈도우? -> k개를 모두 보면서 
모노톤 덱?
k가 1인 경우에는 제일 작은수 리턴

k가 1이 아니면 모든걸 다 봐야함. 이때 중복 계산이 싫은거임
k가 2 -> 이십만개
여기서 중요한건 제일 작은 수를 유지해야하는것.

슬라이딩 윈도우 -> 모노톤덱을 쓰면 해결될 듯?
1. 윈도우 옮길때마다 가장 왼쪽은 빼고, 가장 오른쪽은 더해야함.
2. 우리는 최소값을 알고있어야하니까 이 최소값이 뭔지를 항상 빠르게 알아야함.
3. deque을 하나 유지할꺼임. dq에는 (값, )
'''
from collections import deque
def solution(stones, k):
    
    if k == 1:
        return min(stones)
    dq = deque()
    minn = 200000001
    # 1. k-1개의 원소 넣기
    # 2. 원소가 들어갈 때 [-1]보다 크다? 그러면 작을때까지 pop()하기
    # 3. k-1부터 쭉 모노톤 진행
    def insert(idx):
        # 만약 왼쪽꺼를 빼야한다면 빼기
        if dq and dq[0][1] < idx-k+1:
            dq.popleft()
        
        # 제일 왼쪽에 잇는거는 최대값을 가지고있어야 한다.
        while dq and dq[-1][0] < stones[idx]: # dq에 원소가 존재 + 더 큰값이 들어온다면
            dq.pop()
        
        dq.append((stones[idx], idx)) # 값, idx
        
    for i in range(len(stones)):
        insert(i)
        if i >= k-1:
            minn = min(minn, dq[0][0])
        
    # zzzz 우리는 최대값을 찾아야함.... 최대값중 최소를 찾아야한다..
        
    
    return minn